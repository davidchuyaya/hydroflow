<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Streaming elements of type `V` grouped by a key of type `K`."><title>KeyedStream in hydro_lang::live_collections - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="hydro_lang" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (9f32ccf35 2025-09-21)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">KeyedStream</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../hydro_lang/index.html">hydro_<wbr>lang</a><span class="version">0.14.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Keyed<wbr>Stream</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.all_ticks" title="all_ticks">all_ticks</a></li><li><a href="#method.all_ticks_atomic" title="all_ticks_atomic">all_ticks_atomic</a></li><li><a href="#method.assume_ordering" title="assume_ordering">assume_ordering</a></li><li><a href="#method.assume_retries" title="assume_retries">assume_retries</a></li><li><a href="#method.atomic" title="atomic">atomic</a></li><li><a href="#method.batch" title="batch">batch</a></li><li><a href="#method.batch-1" title="batch">batch</a></li><li><a href="#method.chain" title="chain">chain</a></li><li><a href="#method.defer_tick" title="defer_tick">defer_tick</a></li><li><a href="#method.demux_bincode" title="demux_bincode">demux_bincode</a></li><li><a href="#method.demux_bincode-1" title="demux_bincode">demux_bincode</a></li><li><a href="#method.end_atomic" title="end_atomic">end_atomic</a></li><li><a href="#method.entries" title="entries">entries</a></li><li><a href="#method.filter" title="filter">filter</a></li><li><a href="#method.filter_key_not_in" title="filter_key_not_in">filter_key_not_in</a></li><li><a href="#method.filter_map" title="filter_map">filter_map</a></li><li><a href="#method.filter_map_with_key" title="filter_map_with_key">filter_map_with_key</a></li><li><a href="#method.filter_with_key" title="filter_with_key">filter_with_key</a></li><li><a href="#method.first" title="first">first</a></li><li><a href="#method.flat_map_ordered" title="flat_map_ordered">flat_map_ordered</a></li><li><a href="#method.flat_map_unordered" title="flat_map_unordered">flat_map_unordered</a></li><li><a href="#method.flatten_ordered" title="flatten_ordered">flatten_ordered</a></li><li><a href="#method.flatten_unordered" title="flatten_unordered">flatten_unordered</a></li><li><a href="#method.fold" title="fold">fold</a></li><li><a href="#method.fold_commutative" title="fold_commutative">fold_commutative</a></li><li><a href="#method.fold_commutative_idempotent" title="fold_commutative_idempotent">fold_commutative_idempotent</a></li><li><a href="#method.fold_early_stop" title="fold_early_stop">fold_early_stop</a></li><li><a href="#method.fold_idempotent" title="fold_idempotent">fold_idempotent</a></li><li><a href="#method.generator" title="generator">generator</a></li><li><a href="#method.inspect" title="inspect">inspect</a></li><li><a href="#method.inspect_with_key" title="inspect_with_key">inspect_with_key</a></li><li><a href="#method.interleave" title="interleave">interleave</a></li><li><a href="#method.ir_node_named" title="ir_node_named">ir_node_named</a></li><li><a href="#method.map" title="map">map</a></li><li><a href="#method.map_with_key" title="map_with_key">map_with_key</a></li><li><a href="#method.reduce" title="reduce">reduce</a></li><li><a href="#method.reduce_commutative" title="reduce_commutative">reduce_commutative</a></li><li><a href="#method.reduce_commutative_idempotent" title="reduce_commutative_idempotent">reduce_commutative_idempotent</a></li><li><a href="#method.reduce_idempotent" title="reduce_idempotent">reduce_idempotent</a></li><li><a href="#method.reduce_watermark" title="reduce_watermark">reduce_watermark</a></li><li><a href="#method.reduce_watermark_commutative" title="reduce_watermark_commutative">reduce_watermark_commutative</a></li><li><a href="#method.reduce_watermark_commutative_idempotent" title="reduce_watermark_commutative_idempotent">reduce_watermark_commutative_idempotent</a></li><li><a href="#method.reduce_watermark_idempotent" title="reduce_watermark_idempotent">reduce_watermark_idempotent</a></li><li><a href="#method.scan" title="scan">scan</a></li><li><a href="#method.values" title="values">values</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+R%3E" title="Clone">Clone</a></li><li><a href="#impl-From%3CKeyedStream%3CK,+V,+L,+B,+TotalOrder,+R%3E%3E-for-KeyedStream%3CK,+V,+L,+B,+NoOrder,+R%3E" title="From&#60;KeyedStream&#60;K, V, L, B, TotalOrder, R&#62;&#62;">From&#60;KeyedStream&#60;K, V, L, B, TotalOrder, R&#62;&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!Sync">!Sync</a></li><li><a href="#impl-UnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Unpin-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-DynClone-for-T" title="DynClone">DynClone</a></li><li><a href="#impl-ErasedDestructor-for-T" title="ErasedDestructor">ErasedDestructor</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-PolicyExt-for-T" title="PolicyExt">PolicyExt</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In hydro_<wbr>lang::<wbr>live_<wbr>collections</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">hydro_lang</a>::<wbr><a href="index.html">live_collections</a></div><h1>Struct <span class="struct">Keyed<wbr>Stream</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#44-54">Source</a> </span></div><pre class="rust item-decl"><code>pub struct KeyedStream&lt;K, V, Loc, Bound: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, Order: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a> = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a> = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Streaming elements of type <code>V</code> grouped by a key of type <code>K</code>.</p>
<p>Keyed Streams capture streaming elements of type <code>V</code> grouped by a key of type <code>K</code>, where the
order of keys is non-deterministic but the order <em>within</em> each group may be deterministic.</p>
<p>Although keyed streams are conceptually grouped by keys, values are not immediately grouped
into buckets when constructing a keyed stream. Instead, keyed streams defer grouping until an
operator such as <a href="struct.KeyedStream.html#method.fold" title="method hydro_lang::live_collections::KeyedStream::fold"><code>KeyedStream::fold</code></a> is called, which requires <code>K: Hash + Eq</code>.</p>
<p>Type Parameters:</p>
<ul>
<li><code>K</code>: the type of the key for each group</li>
<li><code>V</code>: the type of the elements inside each group</li>
<li><code>Loc</code>: the <a href="../location/trait.Location.html" title="trait hydro_lang::location::Location"><code>Location</code></a> where the keyed stream is materialized</li>
<li><code>Bound</code>: tracks whether the entries are <a href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a> (local and finite) or <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a> (asynchronous and possibly infinite)</li>
<li><code>Order</code>: tracks whether the elements within each group have deterministic order
(<a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a>) or not (<a href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder"><code>NoOrder</code></a>)</li>
<li><code>Retries</code>: tracks whether the elements within each group have deterministic cardinality
(<a href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce"><code>ExactlyOnce</code></a>) or may have non-deterministic retries (<a href="stream/enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce"><code>crate::live_collections::stream::AtLeastOnce</code></a>)</li>
</ul>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CMemberId%3CL2%3E,+T,+Process%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#16-76">Source</a><a href="#impl-KeyedStream%3CMemberId%3CL2%3E,+T,+Process%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, L2, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L2&gt;, T, <a class="struct" href="../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.demux_bincode" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#54-75">Source</a><h4 class="code-header">pub fn <a href="#method.demux_bincode" class="fn">demux_bincode</a>(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Sends each group of this stream to a specific member of a cluster, with the <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> key
identifying the recipient for each group and using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>Each key must be a <code>MemberId&lt;L2&gt;</code> and each value must be a <code>T</code> where the key specifies
which cluster member should receive the data. Unlike <a href="struct.Stream.html#method.broadcast_bincode" title="method hydro_lang::live_collections::Stream::broadcast_bincode"><code>Stream::broadcast_bincode</code></a>, this
API allows precise targeting of specific cluster members rather than broadcasting to
all members.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>p1 = flow.process::&lt;()&gt;();
<span class="kw">let </span>workers: Cluster&lt;()&gt; = flow.cluster::&lt;()&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = p1.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
<span class="kw">let </span>on_worker: Stream&lt;<span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = numbers
    .map(<span class="macro">q!</span>(|x| (hydro_lang::location::MemberId::from_raw(x), x)))
    .into_keyed()
    .demux_bincode(<span class="kw-2">&amp;</span>workers);
<span class="comment">// if there are 4 members in the cluster, each receives one element
// - MemberId::&lt;()&gt;(0): [0]
// - MemberId::&lt;()&gt;(1): [1]
// - MemberId::&lt;()&gt;(2): [2]
// - MemberId::&lt;()&gt;(3): [3]</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CMemberId%3CL2%3E,+T,+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#78-150">Source</a><a href="#impl-KeyedStream%3CMemberId%3CL2%3E,+T,+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, L2, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L2&gt;, T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.demux_bincode-1" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#126-149">Source</a><h4 class="code-header">pub fn <a href="#method.demux_bincode-1" class="fn">demux_bincode</a>(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L&gt;, T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Sends each group of this stream at each source member to a specific member of a destination
cluster, with the <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> key identifying the recipient for each group and using
<a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>Each key must be a <code>MemberId&lt;L2&gt;</code> and each value must be a <code>T</code> where the key specifies
which cluster member should receive the data. Unlike <a href="struct.Stream.html#method.broadcast_bincode" title="method hydro_lang::live_collections::Stream::broadcast_bincode"><code>Stream::broadcast_bincode</code></a>, this
API allows precise targeting of specific cluster members rather than broadcasting to all
members.</p>
<p>Each cluster member sends its local stream elements, and they are collected at each
destination member as a <a href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream"><code>KeyedStream</code></a> where keys identify the source cluster member.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>source: Cluster&lt;Source&gt; = flow.cluster::&lt;Source&gt;();
<span class="kw">let </span>to_send: KeyedStream&lt;<span class="kw">_</span>, <span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = source
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))
    .map(<span class="macro">q!</span>(|x| (hydro_lang::location::MemberId::from_raw(x), x)))
    .into_keyed();
<span class="kw">let </span>destination: Cluster&lt;Destination&gt; = flow.cluster::&lt;Destination&gt;();
<span class="kw">let </span>all_received = to_send.demux_bincode(<span class="kw-2">&amp;</span>destination); <span class="comment">// KeyedStream&lt;MemberId&lt;Source&gt;, i32, ...&gt;
// if there are 4 members in the destination cluster, each receives one message from each source member
// - Destination(0): { Source(0): [0], Source(1): [0], ... }
// - Destination(1): { Source(0): [1], Source(1): [1], ... }
// - ...</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#102-647">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.assume_ordering" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#113-118">Source</a><h4 class="code-header">pub fn <a href="#method.assume_ordering" class="fn">assume_ordering</a>&lt;O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt;(
    self,
    _nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O2, R&gt;</h4></section></summary><div class="docblock"><p>Explicitly “casts” the keyed stream to a type with a different ordering
guarantee for each group. Useful in unsafe code where the ordering cannot be proven
by the type-system.</p>
<h5 id="non-determinism"><a class="doc-anchor" href="#non-determinism">§</a>Non-Determinism</h5>
<p>This function is used as an escape hatch, and any mistakes in the
provided ordering guarantee will propagate into the guarantees
for the rest of the program.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_retries" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#128-133">Source</a><h4 class="code-header">pub fn <a href="#method.assume_retries" class="fn">assume_retries</a>&lt;R2: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R2&gt;</h4></section></summary><div class="docblock"><p>Explicitly “casts” the keyed stream to a type with a different retries
guarantee for each group. Useful in unsafe code where the lack of retries cannot
be proven by the type-system.</p>
<h5 id="non-determinism-1"><a class="doc-anchor" href="#non-determinism-1">§</a>Non-Determinism</h5>
<p>This function is used as an escape hatch, and any mistakes in the
provided retries guarantee will propagate into the guarantees
for the rest of the program.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.entries" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#153-155">Source</a><h4 class="code-header">pub fn <a href="#method.entries" class="fn">entries</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section></summary><div class="docblock"><p>Flattens the keyed stream into an unordered stream of key-value pairs.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .entries()
<span class="comment">// (1, 2), (1, 3), (2, 4) in any order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.values" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#175-177">Source</a><h4 class="code-header">pub fn <a href="#method.values" class="fn">values</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;V, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section></summary><div class="docblock"><p>Flattens the keyed stream into an unordered stream of only the values.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .values()
<span class="comment">// 2, 3, 4 in any order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.map" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#202-214">Source</a><h4 class="code-header">pub fn <a href="#method.map" class="fn">map</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(V) -&gt; U + 'a,</div></h4></section></summary><div class="docblock"><p>Transforms each value by invoking <code>f</code> on each element, with keys staying the same
after transformation. If you need access to the key, see <a href="struct.KeyedStream.html#method.map_with_key" title="method hydro_lang::live_collections::KeyedStream::map_with_key"><code>KeyedStream::map_with_key</code></a>.</p>
<p>If you do not want to modify the stream and instead only want to view
each item use <a href="struct.KeyedStream.html#method.inspect" title="method hydro_lang::live_collections::KeyedStream::inspect"><code>KeyedStream::inspect</code></a> instead.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .map(<span class="macro">q!</span>(|v| v + <span class="number">1</span>))
<span class="comment">// { 1: [3, 4], 2: [5] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.map_with_key" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#239-258">Source</a><h4 class="code-header">pub fn <a href="#method.map_with_key" class="fn">map_with_key</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>) -&gt; U + 'a,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Transforms each value by invoking <code>f</code> on each key-value pair. The resulting values are <strong>not</strong>
re-grouped even they are tuples; instead they will be grouped under the original key.</p>
<p>If you do not want to modify the stream and instead only want to view
each item use <a href="struct.KeyedStream.html#method.inspect_with_key" title="method hydro_lang::live_collections::KeyedStream::inspect_with_key"><code>KeyedStream::inspect_with_key</code></a> instead.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .map_with_key(<span class="macro">q!</span>(|(k, v)| k + v))
<span class="comment">// { 1: [3, 4], 2: [6] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#284-296">Source</a><h4 class="code-header">pub fn <a href="#method.filter" class="fn">filter</a>&lt;F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;V</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + 'a,</div></h4></section></summary><div class="docblock"><p>Creates a stream containing only the elements of each group stream that satisfy a predicate
<code>f</code>, preserving the order of the elements within the group.</p>
<p>The closure <code>f</code> receives a reference <code>&amp;V</code> rather than an owned value <code>v</code> because filtering does
not modify or take ownership of the values. If you need to modify the values while filtering
use <a href="struct.KeyedStream.html#method.filter_map" title="method hydro_lang::live_collections::KeyedStream::filter_map"><code>KeyedStream::filter_map</code></a> instead.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .filter(<span class="macro">q!</span>(|<span class="kw-2">&amp;</span>x| x &gt; <span class="number">2</span>))
<span class="comment">// { 1: [3], 2: [4] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_with_key" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#322-333">Source</a><h4 class="code-header">pub fn <a href="#method.filter_with_key" class="fn">filter_with_key</a>&lt;F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + 'a,</div></h4></section></summary><div class="docblock"><p>Creates a stream containing only the elements of each group stream that satisfy a predicate
<code>f</code> (which receives the key-value tuple), preserving the order of the elements within the group.</p>
<p>The closure <code>f</code> receives a reference <code>&amp;(K, V)</code> rather than an owned value <code>(K, V)</code> because filtering does
not modify or take ownership of the values. If you need to modify the values while filtering
use <a href="struct.KeyedStream.html#method.filter_map_with_key" title="method hydro_lang::live_collections::KeyedStream::filter_map_with_key"><code>KeyedStream::filter_map_with_key</code></a> instead.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .filter_with_key(<span class="macro">q!</span>(|<span class="kw-2">&amp;</span>(k, v)| v - k == <span class="number">2</span>))
<span class="comment">// { 1: [3], 2: [4] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_map" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#356-371">Source</a><h4 class="code-header">pub fn <a href="#method.filter_map" class="fn">filter_map</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(V) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a,</div></h4></section></summary><div class="docblock"><p>An operator that both filters and maps each value, with keys staying the same.
It yields only the items for which the supplied closure <code>f</code> returns <code>Some(value)</code>.
If you need access to the key, see <a href="struct.KeyedStream.html#method.filter_map_with_key" title="method hydro_lang::live_collections::KeyedStream::filter_map_with_key"><code>KeyedStream::filter_map_with_key</code></a>.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="string">"2"</span>), (<span class="number">1</span>, <span class="string">"hello"</span>), (<span class="number">2</span>, <span class="string">"4"</span>)]))
    .into_keyed()
    .filter_map(<span class="macro">q!</span>(|s| s.parse::&lt;usize&gt;().ok()))
<span class="comment">// { 1: [2], 2: [4] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_map_with_key" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#394-413">Source</a><h4 class="code-header">pub fn <a href="#method.filter_map_with_key" class="fn">filter_map_with_key</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>An operator that both filters and maps each key-value pair. The resulting values are <strong>not</strong>
re-grouped even they are tuples; instead they will be grouped under the original key.
It yields only the items for which the supplied closure <code>f</code> returns <code>Some(value)</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="string">"2"</span>), (<span class="number">1</span>, <span class="string">"hello"</span>), (<span class="number">2</span>, <span class="string">"2"</span>)]))
    .into_keyed()
    .filter_map_with_key(<span class="macro">q!</span>(|(k, s)| s.parse::&lt;usize&gt;().ok().filter(|v| v == <span class="kw-2">&amp;</span>k)))
<span class="comment">// { 2: [2] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_ordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#440-457">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_ordered" class="fn">flat_map_ordered</a>&lt;U, I, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(V) -&gt; I + 'a,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>For each value <code>v</code> in each group, transform <code>v</code> using <code>f</code> and then treat the
result as an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> to produce values one by one within the same group.
The implementation for <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> for the output type <code>I</code> must produce items
in a <strong>deterministic</strong> order.</p>
<p>For example, <code>I</code> could be a <code>Vec</code>, but not a <code>HashSet</code>. If the order of the items in <code>I</code> is
not deterministic, use <a href="struct.KeyedStream.html#method.flat_map_unordered" title="method hydro_lang::live_collections::KeyedStream::flat_map_unordered"><code>KeyedStream::flat_map_unordered</code></a> instead.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">3</span>]), (<span class="number">1</span>, <span class="macro">vec!</span>[<span class="number">4</span>]), (<span class="number">2</span>, <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">6</span>])]))
    .into_keyed()
    .flat_map_ordered(<span class="macro">q!</span>(|x| x))
<span class="comment">// { 1: [2, 3, 4], 2: [5, 6] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_unordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#485-502">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_unordered" class="fn">flat_map_unordered</a>&lt;U, I, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(V) -&gt; I + 'a,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Like <a href="struct.KeyedStream.html#method.flat_map_ordered" title="method hydro_lang::live_collections::KeyedStream::flat_map_ordered"><code>KeyedStream::flat_map_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the output type <code>I</code> to produce items in any order.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[
        (<span class="number">1</span>, std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">3</span>])),
        (<span class="number">2</span>, std::collections::HashSet::from_iter(<span class="macro">vec!</span>[<span class="number">4</span>, <span class="number">5</span>]))
    ]))
    .into_keyed()
    .flat_map_unordered(<span class="macro">q!</span>(|x| x))
<span class="comment">// { 1: [2, 3], 2: [4, 5] } with values in each group in unknown order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_ordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#528-534">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_ordered" class="fn">flatten_ordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>For each value <code>v</code> in each group, treat <code>v</code> as an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> and produce its items one by one
within the same group. The implementation for <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> for the value type <code>V</code> must produce
items in a <strong>deterministic</strong> order.</p>
<p>For example, <code>V</code> could be a <code>Vec</code>, but not a <code>HashSet</code>. If the order of the items in <code>V</code> is
not deterministic, use <a href="struct.KeyedStream.html#method.flatten_unordered" title="method hydro_lang::live_collections::KeyedStream::flatten_unordered"><code>KeyedStream::flatten_unordered</code></a> instead.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">3</span>]), (<span class="number">1</span>, <span class="macro">vec!</span>[<span class="number">4</span>]), (<span class="number">2</span>, <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">6</span>])]))
    .into_keyed()
    .flatten_ordered()
<span class="comment">// { 1: [2, 3, 4], 2: [5, 6] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_unordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#562-568">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_unordered" class="fn">flatten_unordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Like <a href="struct.KeyedStream.html#method.flatten_ordered" title="method hydro_lang::live_collections::KeyedStream::flatten_ordered"><code>KeyedStream::flatten_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the value type <code>V</code> to produce items in any order.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[
        (<span class="number">1</span>, std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">3</span>])),
        (<span class="number">2</span>, std::collections::HashSet::from_iter(<span class="macro">vec!</span>[<span class="number">4</span>, <span class="number">5</span>]))
    ]))
    .into_keyed()
    .flatten_unordered()
<span class="comment">// { 1: [2, 3], 2: [4, 5] } with values in each group in unknown order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.inspect" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#590-602">Source</a><h4 class="code-header">pub fn <a href="#method.inspect" class="fn">inspect</a>&lt;F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;V</a>) + 'a,</div></h4></section></summary><div class="docblock"><p>An operator which allows you to “inspect” each element of a stream without
modifying it. The closure <code>f</code> is called on a reference to each value. This is
mainly useful for debugging, and should not be used to generate side-effects.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .inspect(<span class="macro">q!</span>(|v| <span class="macro">println!</span>(<span class="string">"{}"</span>, v)))</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.inspect_with_key" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#624-635">Source</a><h4 class="code-header">pub fn <a href="#method.inspect_with_key" class="fn">inspect_with_key</a>&lt;F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>) + 'a,</div></h4></section></summary><div class="docblock"><p>An operator which allows you to “inspect” each element of a stream without
modifying it. The closure <code>f</code> is called on a reference to each key-value pair. This is
mainly useful for debugging, and should not be used to generate side-effects.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .inspect_with_key(<span class="macro">q!</span>(|(k, v)| <span class="macro">println!</span>(<span class="string">"{}: {}"</span>, k, v)))</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ir_node_named" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#639-646">Source</a><h4 class="code-header">pub fn <a href="#method.ir_node_named" class="fn">ir_node_named</a>(self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>An operator which allows you to “name” a <code>HydroNode</code>.
This is only used for testing, to correlate certain <code>HydroNode</code>s with IDs.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+Unbounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#649-684">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+Unbounded,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a> + <a class="trait" href="../location/tick/trait.NoAtomic.html" title="trait hydro_lang::location::tick::NoAtomic">NoAtomic</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.interleave" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#675-683">Source</a><h4 class="code-header">pub fn <a href="#method.interleave" class="fn">interleave</a>&lt;O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    other: <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O2, R2&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, &lt;R as <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;&gt;::<a class="associatedtype" href="stream/trait.MinRetries.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinRetries::Min">Min</a>&gt;<div class="where">where
    R: <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;,</div></h4></section></summary><div class="docblock"><p>Produces a new keyed stream that “merges” the inputs by interleaving the elements
of any overlapping groups. The result has <a href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder"><code>NoOrder</code></a> on each group because the
order of interleaving is not guaranteed. If the keys across both inputs do not overlap,
the ordering will be deterministic and you can safely use <a href="struct.KeyedStream.html#method.assume_ordering" title="method hydro_lang::live_collections::KeyedStream::assume_ordering"><code>Self::assume_ordering</code></a>.</p>
<p>Currently, both input streams must be <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a>.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>numbers1 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)])).into_keyed();
<span class="kw">let </span>numbers2 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">5</span>)])).into_keyed();
numbers1.interleave(numbers2)
<span class="comment">// { 1: [2, 3], 3: [4, 5] } with each group in unknown order</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#699-1097">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.scan" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#737-761">Source</a><h4 class="code-header">pub fn <a href="#method.scan" class="fn">scan</a>&lt;A, U, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a,</div></h4></section></summary><div class="docblock"><p>A special case of <a href="struct.Stream.html#method.scan" title="method hydro_lang::live_collections::Stream::scan"><code>Stream::scan</code></a> for keyed streams. For each key group the values are transformed via the <code>f</code> combinator.</p>
<p>Unlike <a href="struct.Stream.html#method.fold_keyed" title="method hydro_lang::live_collections::Stream::fold_keyed"><code>Stream::fold_keyed</code></a> which only returns the final accumulated value, <code>scan</code> produces a new stream
containing all intermediate accumulated values paired with the key. The scan operation can also terminate
early by returning <code>None</code>.</p>
<p>The function takes a mutable reference to the accumulator and the current element, and returns
an <code>Option&lt;U&gt;</code>. If the function returns <code>Some(value)</code>, <code>value</code> is emitted to the output stream.
If the function returns <code>None</code>, the stream is terminated and no more elements are processed.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>)]))
    .into_keyed()
    .scan(
        <span class="macro">q!</span>(|| <span class="number">0</span>),
        <span class="macro">q!</span>(|acc, x| {
            <span class="kw-2">*</span>acc += x;
            <span class="kw">if </span><span class="kw-2">*</span>acc % <span class="number">2 </span>== <span class="number">0 </span>{ <span class="prelude-val">None </span>} <span class="kw">else </span>{ <span class="prelude-val">Some</span>(<span class="kw-2">*</span>acc) }
        }),
    )
<span class="comment">// Output: { 0: [1], 1: [3, 7] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.generator" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#806-851">Source</a><h4 class="code-header">pub fn <a href="#method.generator" class="fn">generator</a>&lt;A, U, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) -&gt; <a class="enum" href="keyed_stream/enum.Generate.html" title="enum hydro_lang::live_collections::keyed_stream::Generate">Generate</a>&lt;U&gt; + 'a,</div></h4></section></summary><div class="docblock"><p>Iteratively processes the elements in each group using a state machine that can yield
elements as it processes its inputs. This is designed to mirror the unstable generator
syntax in Rust, without requiring special syntax.</p>
<p>Like <a href="struct.KeyedStream.html#method.scan" title="method hydro_lang::live_collections::KeyedStream::scan"><code>KeyedStream::scan</code></a>, this function takes in an initializer that emits the initial
state for each group. The second argument defines the processing logic, taking in a
mutable reference to the group’s state and the value to be processed. It emits a
<a href="keyed_stream/enum.Generate.html" title="enum hydro_lang::live_collections::keyed_stream::Generate"><code>Generate</code></a> value, whose variants define what is emitted and whether further inputs
should be processed.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">100</span>), (<span class="number">0</span>, <span class="number">10</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">3</span>)]))
    .into_keyed()
    .generator(
        <span class="macro">q!</span>(|| <span class="number">0</span>),
        <span class="macro">q!</span>(|acc, x| {
            <span class="kw-2">*</span>acc += x;
            <span class="kw">if </span><span class="kw-2">*</span>acc &gt; <span class="number">100 </span>{
                hydro_lang::live_collections::keyed_stream::Generate::Return(
                    <span class="string">"done!"</span>.to_string()
                )
            } <span class="kw">else if </span><span class="kw-2">*</span>acc % <span class="number">2 </span>== <span class="number">0 </span>{
                hydro_lang::live_collections::keyed_stream::Generate::Yield(
                    <span class="string">"even"</span>.to_string()
                )
            } <span class="kw">else </span>{
                hydro_lang::live_collections::keyed_stream::Generate::Continue
            }
        }),
    )
<span class="comment">// Output: { 0: ["even", "done!"], 1: ["even"] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fold_early_stop" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#883-915">Source</a><h4 class="code-header">pub fn <a href="#method.fold_early_stop" class="fn">fold_early_stop</a>&lt;A, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, A, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueBounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueBounded">WhenValueBounded</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + 'a,</div></h4></section></summary><div class="docblock"><p>A variant of <a href="struct.Stream.html#method.fold" title="method hydro_lang::live_collections::Stream::fold"><code>Stream::fold</code></a>, intended for keyed streams. The aggregation is executed
in-order across the values in each group. But the aggregation function returns a boolean,
which when true indicates that the aggregated result is complete and can be released to
downstream computation. Unlike <a href="struct.Stream.html#method.fold_keyed" title="method hydro_lang::live_collections::Stream::fold_keyed"><code>Stream::fold_keyed</code></a>, this means that even if the input
stream is <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>super::boundedness::Unbounded</code></a>, the outputs of the fold can be processed like
normal stream elements.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">6</span>)]))
    .into_keyed()
    .fold_early_stop(
        <span class="macro">q!</span>(|| <span class="number">0</span>),
        <span class="macro">q!</span>(|acc, x| {
            <span class="kw-2">*</span>acc += x;
            x % <span class="number">2 </span>== <span class="number">0
        </span>}),
    )
<span class="comment">// Output: { 0: 2, 1: 9 }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.first" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#938-950">Source</a><h4 class="code-header">pub fn <a href="#method.first" class="fn">first</a>(self) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueBounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueBounded">WhenValueBounded</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Gets the first element inside each group of values as a <a href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton"><code>KeyedSingleton</code></a> that preserves
the original group keys. Requires the input stream to have <a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantees,
otherwise the first element would be non-deterministic.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">6</span>)]))
    .into_keyed()
    .first()
<span class="comment">// Output: { 0: 2, 1: 3 }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fold" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#980-1000">Source</a><h4 class="code-header">pub fn <a href="#method.fold" class="fn">fold</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V)&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, A, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.fold" title="method hydro_lang::live_collections::Stream::fold"><code>Stream::fold</code></a>, aggregates the values in each group via the <code>comb</code> closure.</p>
<p>Each group must have a <a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the group.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="struct.KeyedStream.html#method.reduce" title="method hydro_lang::live_collections::KeyedStream::reduce"><code>KeyedStream::reduce</code></a>.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold(<span class="macro">q!</span>(|| <span class="number">0</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .entries()
    .all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1026-1043">Source</a><h4 class="code-header">pub fn <a href="#method.reduce" class="fn">reduce</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.reduce" title="method hydro_lang::live_collections::Stream::reduce"><code>Stream::reduce</code></a>, aggregates the values in each group via the <code>comb</code> closure.</p>
<p>Each group must have a <a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="struct.KeyedStream.html#method.fold" title="method hydro_lang::live_collections::KeyedStream::fold"><code>KeyedStream::fold</code></a>.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.reduce(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x)).entries().all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_watermark" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1070-1096">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_watermark" class="fn">reduce_watermark</a>&lt;O, F&gt;(
    self,
    other: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;O, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;<div class="where">where
    O: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a,</div></h4></section></summary><div class="docblock"><p>A special case of <a href="struct.KeyedStream.html#method.reduce" title="method hydro_lang::live_collections::KeyedStream::reduce"><code>KeyedStream::reduce</code></a> where tuples with keys less than the watermark are automatically deleted.</p>
<p>Each group must have a <a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>watermark = tick.singleton(<span class="macro">q!</span>(<span class="number">1</span>));
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>([(<span class="number">0</span>, <span class="number">100</span>), (<span class="number">1</span>, <span class="number">101</span>), (<span class="number">2</span>, <span class="number">102</span>), (<span class="number">2</span>, <span class="number">102</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_watermark(watermark, <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .entries()
    .all_ticks()
<span class="comment">// (2, 204)</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B,+O%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1099-1210">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_commutative" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1131-1138">Source</a><h4 class="code-header">pub fn <a href="#method.fold_commutative" class="fn">fold_commutative</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V)&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, A, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.fold_commutative" title="method hydro_lang::live_collections::Stream::fold_commutative"><code>Stream::fold_commutative</code></a>, aggregates the values in each group via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="struct.KeyedStream.html#method.reduce_commutative" title="method hydro_lang::live_collections::KeyedStream::reduce_commutative"><code>KeyedStream::reduce_commutative</code></a>.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_commutative(<span class="macro">q!</span>(|| <span class="number">0</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .entries()
    .all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_commutative" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1166-1172">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_commutative" class="fn">reduce_commutative</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.reduce_commutative" title="method hydro_lang::live_collections::Stream::reduce_commutative"><code>Stream::reduce_commutative</code></a>, aggregates the values in each group via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="struct.KeyedStream.html#method.fold_commutative" title="method hydro_lang::live_collections::KeyedStream::fold_commutative"><code>KeyedStream::fold_commutative</code></a>.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_commutative(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .entries()
    .all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_watermark_commutative" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1198-1209">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_watermark_commutative" class="fn">reduce_watermark_commutative</a>&lt;O2, F&gt;(
    self,
    other: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;O2, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;<div class="where">where
    O2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a,</div></h4></section></summary><div class="docblock"><p>A special case of <a href="struct.KeyedStream.html#method.reduce_commutative" title="method hydro_lang::live_collections::KeyedStream::reduce_commutative"><code>KeyedStream::reduce_commutative</code></a> where tuples with keys less than the watermark are automatically deleted.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>watermark = tick.singleton(<span class="macro">q!</span>(<span class="number">1</span>));
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>([(<span class="number">0</span>, <span class="number">100</span>), (<span class="number">1</span>, <span class="number">101</span>), (<span class="number">2</span>, <span class="number">102</span>), (<span class="number">2</span>, <span class="number">102</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_watermark_commutative(watermark, <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .entries()
    .all_ticks()
<span class="comment">// (2, 204)</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B,+TotalOrder,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1212-1323">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B,+TotalOrder,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_idempotent" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1244-1251">Source</a><h4 class="code-header">pub fn <a href="#method.fold_idempotent" class="fn">fold_idempotent</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V)&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, A, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.fold_idempotent" title="method hydro_lang::live_collections::Stream::fold_idempotent"><code>Stream::fold_idempotent</code></a>, aggregates the values in each group via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>idempotent</strong> as there may be non-deterministic duplicates.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="struct.KeyedStream.html#method.reduce_idempotent" title="method hydro_lang::live_collections::KeyedStream::reduce_idempotent"><code>KeyedStream::reduce_idempotent</code></a>.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_idempotent(<span class="macro">q!</span>(|| <span class="bool-val">false</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .entries()
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_idempotent" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1279-1285">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_idempotent" class="fn">reduce_idempotent</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.reduce_idempotent" title="method hydro_lang::live_collections::Stream::reduce_idempotent"><code>Stream::reduce_idempotent</code></a>, aggregates the values in each group via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>idempotent</strong>, as there may be non-deterministic duplicates.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="struct.KeyedStream.html#method.fold_idempotent" title="method hydro_lang::live_collections::KeyedStream::fold_idempotent"><code>KeyedStream::fold_idempotent</code></a>.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_idempotent(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .entries()
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_watermark_idempotent" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1311-1322">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_watermark_idempotent" class="fn">reduce_watermark_idempotent</a>&lt;O2, F&gt;(
    self,
    other: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;O2, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;<div class="where">where
    O2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a,</div></h4></section></summary><div class="docblock"><p>A special case of <a href="struct.KeyedStream.html#method.reduce_idempotent" title="method hydro_lang::live_collections::KeyedStream::reduce_idempotent"><code>KeyedStream::reduce_idempotent</code></a> where tuples with keys less than the watermark are automatically deleted.</p>
<p>The <code>comb</code> closure must be <strong>idempotent</strong>, as there may be non-deterministic duplicates.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>watermark = tick.singleton(<span class="macro">q!</span>(<span class="number">1</span>));
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>([(<span class="number">0</span>, <span class="bool-val">false</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_watermark_idempotent(watermark, <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .entries()
    .all_ticks()
<span class="comment">// (2, true)</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E-1" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1325-1477">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_commutative_idempotent" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1358-1366">Source</a><h4 class="code-header">pub fn <a href="#method.fold_commutative_idempotent" class="fn">fold_commutative_idempotent</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V)&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, A, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.fold_commutative_idempotent" title="method hydro_lang::live_collections::Stream::fold_commutative_idempotent"><code>Stream::fold_commutative_idempotent</code></a>, aggregates the values in each group via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed, and <strong>idempotent</strong>,
as there may be non-deterministic duplicates.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="struct.KeyedStream.html#method.reduce_commutative_idempotent" title="method hydro_lang::live_collections::KeyedStream::reduce_commutative_idempotent"><code>KeyedStream::reduce_commutative_idempotent</code></a>.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_commutative_idempotent(<span class="macro">q!</span>(|| <span class="bool-val">false</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .entries()
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_commutative_idempotent" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1395-1402">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_commutative_idempotent" class="fn">reduce_commutative_idempotent</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.reduce_commutative_idempotent" title="method hydro_lang::live_collections::Stream::reduce_commutative_idempotent"><code>Stream::reduce_commutative_idempotent</code></a>, aggregates the values in each group via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed, and <strong>idempotent</strong>,
as there may be non-deterministic duplicates.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="struct.KeyedStream.html#method.fold_commutative_idempotent" title="method hydro_lang::live_collections::KeyedStream::fold_commutative_idempotent"><code>KeyedStream::fold_commutative_idempotent</code></a>.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_commutative_idempotent(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .entries()
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_watermark_commutative_idempotent" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1429-1441">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_watermark_commutative_idempotent" class="fn">reduce_watermark_commutative_idempotent</a>&lt;O2, F&gt;(
    self,
    other: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;O2, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;<div class="where">where
    O2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a,</div></h4></section></summary><div class="docblock"><p>A special case of <a href="struct.Stream.html#method.reduce_keyed_commutative_idempotent" title="method hydro_lang::live_collections::Stream::reduce_keyed_commutative_idempotent"><code>Stream::reduce_keyed_commutative_idempotent</code></a> where tuples with keys less than the watermark are automatically deleted.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed, and <strong>idempotent</strong>,
as there may be non-deterministic duplicates.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>watermark = tick.singleton(<span class="macro">q!</span>(<span class="number">1</span>));
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>([(<span class="number">0</span>, <span class="bool-val">false</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_watermark_commutative_idempotent(watermark, <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .entries()
    .all_ticks()
<span class="comment">// (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_key_not_in" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1468-1476">Source</a><h4 class="code-header">pub fn <a href="#method.filter_key_not_in" class="fn">filter_key_not_in</a>&lt;O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    other: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;K, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O2, R2&gt;,
) -&gt; Self</h4></section></summary><div class="docblock"><p>Given a bounded stream of keys <code>K</code>, returns a new keyed stream containing only the groups
whose keys are not in the bounded stream.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>keyed_stream = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[ (<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">4</span>, <span class="string">'d'</span>) ]))
    .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>))
    .into_keyed();
<span class="kw">let </span>keys_to_remove = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]))
    .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
keyed_stream.filter_key_not_in(keys_to_remove).all_ticks()
<span class="comment">// { 3: ['c'], 4: ['d'] }</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E-2" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1479-1511">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a> + <a class="trait" href="../location/tick/trait.NoAtomic.html" title="trait hydro_lang::location::tick::NoAtomic">NoAtomic</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1491-1496">Source</a><h4 class="code-header">pub fn <a href="#method.atomic" class="fn">atomic</a>(self, tick: &amp;<a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Shifts this keyed stream into an atomic context, which guarantees that any downstream logic
will all be executed synchronously before any outputs are yielded (in <a href="struct.KeyedStream.html#method.end_atomic" title="method hydro_lang::live_collections::KeyedStream::end_atomic"><code>KeyedStream::end_atomic</code></a>).</p>
<p>This is useful to enforce local consistency constraints, such as ensuring that a write is
processed before an acknowledgement is emitted. Entering an atomic section requires a <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a>
argument that declares where the stream will be atomically processed. Batching a stream into
the <em>same</em> <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> will preserve the synchronous execution, while batching into a different
<a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> will introduce asynchrony.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.batch" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1504-1510">Source</a><h4 class="code-header">pub fn <a href="#method.batch" class="fn">batch</a>(
    self,
    tick: &amp;<a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;,
    nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Given a tick, returns a keyed stream corresponding to a batch of elements segmented by
that tick. These batches are guaranteed to be contiguous across ticks and preserve
the order of the input.</p>
<h5 id="non-determinism-2"><a class="doc-anchor" href="#non-determinism-2">§</a>Non-Determinism</h5>
<p>The batch boundaries are non-deterministic and may change across executions.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+Atomic%3CL%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1513-1539">Source</a><a href="#impl-KeyedStream%3CK,+V,+Atomic%3CL%3E,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a> + <a class="trait" href="../location/tick/trait.NoAtomic.html" title="trait hydro_lang::location::tick::NoAtomic">NoAtomic</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.batch-1" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1524-1529">Source</a><h4 class="code-header">pub fn <a href="#method.batch-1" class="fn">batch</a>(self, nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Returns a keyed stream corresponding to the latest batch of elements being atomically
processed. These batches are guaranteed to be contiguous across ticks and preserve
the order of the input. The output keyed stream will execute in the <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> that was
used to create the atomic section.</p>
<h5 id="non-determinism-3"><a class="doc-anchor" href="#non-determinism-3">§</a>Non-Determinism</h5>
<p>The batch boundaries are non-deterministic and may change across executions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.end_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1533-1538">Source</a><h4 class="code-header">pub fn <a href="#method.end_atomic" class="fn">end_atomic</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Yields the elements of this keyed stream back into a top-level, asynchronous execution context.
See <a href="struct.KeyedStream.html#method.atomic" title="method hydro_lang::live_collections::KeyedStream::atomic"><code>KeyedStream::atomic</code></a> for more details.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1541-1583">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+Bounded,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.chain" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1571-1582">Source</a><h4 class="code-header">pub fn <a href="#method.chain" class="fn">chain</a>&lt;O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt;(
    self,
    other: <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O2, R&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, &lt;O as <a class="trait" href="stream/trait.MinOrder.html" title="trait hydro_lang::live_collections::stream::MinOrder">MinOrder</a>&lt;O2&gt;&gt;::<a class="associatedtype" href="stream/trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinOrder::Min">Min</a>, R&gt;<div class="where">where
    O: <a class="trait" href="stream/trait.MinOrder.html" title="trait hydro_lang::live_collections::stream::MinOrder">MinOrder</a>&lt;O2&gt;,</div></h4></section></summary><div class="docblock"><p>Produces a new keyed stream that combines the groups of the inputs by first emitting the
elements of the <code>self</code> stream, and then emits the elements of the <code>other</code> stream (if a key
is only present in one of the inputs, its values are passed through as-is). The output has
a <a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee if and only if both inputs have a <a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee.</p>
<p>Currently, both input streams must be <a href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a>. This operator will block
on the first stream until all its elements are available. In a future version,
we will relax the requirement on the <code>other</code> stream.</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)])).into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.clone().map(<span class="macro">q!</span>(|x| x + <span class="number">1</span>)).chain(batch).all_ticks()
<span class="comment">// { 0: [2, 1], 1: [4, 3] }</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1585-1620">Source</a><a href="#impl-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.all_ticks" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1592-1597">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks" class="fn">all_ticks</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Asynchronously yields this batch of keyed elements outside the tick as an unbounded keyed stream,
which will stream all the elements across <em>all</em> tick iterations by concatenating the batches for
each key.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.all_ticks_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1606-1611">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks_atomic" class="fn">all_ticks_atomic</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Synchronously yields this batch of keyed elements outside the tick as an unbounded keyed stream,
which will stream all the elements across <em>all</em> tick iterations by concatenating the batches for
each key.</p>
<p>Unlike <a href="struct.KeyedStream.html#method.all_ticks" title="method hydro_lang::live_collections::KeyedStream::all_ticks"><code>KeyedStream::all_ticks</code></a>, this preserves synchronous execution, as the output stream
is emitted in an <a href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic"><code>Atomic</code></a> context that will process elements synchronously with the input
stream’s <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> context.</p>
</div></details><section id="method.defer_tick" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1614-1619">Source</a><h4 class="code-header">pub fn <a href="#method.defer_tick" class="fn">defer_tick</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h4></section></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#69-78">Source</a><a href="#impl-Clone-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, Loc: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Bound: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, Order: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#72-77">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CKeyedStream%3CK,+V,+L,+B,+TotalOrder,+R%3E%3E-for-KeyedStream%3CK,+V,+L,+B,+NoOrder,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#56-67">Source</a><a href="#impl-From%3CKeyedStream%3CK,+V,+L,+B,+TotalOrder,+R%3E%3E-for-KeyedStream%3CK,+V,+L,+B,+NoOrder,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;&gt; for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#61-66">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(
    stream: <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Freeze-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, Loc, Bound, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-RefUnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-RefUnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, Loc, Bound, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-Send-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Send-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, Loc, Bound, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-Sync-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Sync-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, Loc, Bound, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-Unpin-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Unpin-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, Loc, Bound, Order, Retry&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;<div class="where">where
    Loc: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Order: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Bound: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Retry: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-UnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, Loc, Bound, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DynClone-for-T" class="impl"><a class="src rightside" href="https://docs.rs/dyn-clone/1.0.20/src/dyn_clone/lib.rs.html#196-198">Source</a><a href="#impl-DynClone-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/dyn-clone/1.0.20/dyn_clone/trait.DynClone.html" title="trait dyn_clone::DynClone">DynClone</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><section id="method.__clone_box" class="method trait-impl"><a class="src rightside" href="https://docs.rs/dyn-clone/1.0.20/src/dyn_clone/lib.rs.html#200">Source</a><a href="#method.__clone_box" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/dyn-clone/1.0.20/dyn_clone/trait.DynClone.html#tymethod.__clone_box" class="fn">__clone_box</a>(&amp;self, _: Private) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PolicyExt-for-T" class="impl"><a href="#impl-PolicyExt-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; PolicyExt for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.and" class="method trait-impl"><a href="#method.and" class="anchor">§</a><h4 class="code-header">fn <a class="fn">and</a>&lt;P, B, E&gt;(self, other: P) -&gt; And&lt;T, P&gt;<div class="where">where
    T: Policy&lt;B, E&gt;,
    P: Policy&lt;B, E&gt;,</div></h4></section></summary><div class='docblock'>Create a new <code>Policy</code> that returns [<code>Action::Follow</code>] only if <code>self</code> and <code>other</code> return
<code>Action::Follow</code>. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.or" class="method trait-impl"><a href="#method.or" class="anchor">§</a><h4 class="code-header">fn <a class="fn">or</a>&lt;P, B, E&gt;(self, other: P) -&gt; Or&lt;T, P&gt;<div class="where">where
    T: Policy&lt;B, E&gt;,
    P: Policy&lt;B, E&gt;,</div></h4></section></summary><div class='docblock'>Create a new <code>Policy</code> that returns [<code>Action::Follow</code>] if either <code>self</code> or <code>other</code> returns
<code>Action::Follow</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.18.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.18.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.18.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.18.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-86">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="crate::dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details><section id="impl-ErasedDestructor-for-T" class="impl"><a href="#impl-ErasedDestructor-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; ErasedDestructor for T<div class="where">where
    T: 'static,</div></h3></section></div></section></div></main></body></html>